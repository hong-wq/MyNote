[TOC]

# Linux多线程

## 进程概述

### 进程与程序

**1.程序**

* 信息文件，一些列程序信息(二进制代码，执行入口、动态库信息等)
* 描述运行时如何创建进程
* 存在磁盘中，是**静态**的

**2.进程**

* 程序运行的实例，是**动态**的
* 操作系统执行的基本单元

一个程序被多次执行就会有多个进程，每个进程都有自己的ID号

### 单道与多道

单道只允许运行一个程序

多道可运行多个程序，穿插执行，提高效率

### 时间片

* 操作系统分配给正在执行的进程微观上的一段CPU时间
* 由内核里的调度程序计算分配

### 并行与并发

并行：某一时刻，多个进程同时执行

并发：多个进程，CPU来回切换执行

![](E:\Note\图片\并发与并行.PNG)



### 进程控制块PCB

* 对进程相关信息的描述
* task_struct 结构体



## 进程的创建

### fork()函数

```c
/*
#include <sys/types.h>
#include <unistd.h>
pid_t fork(void);
    --作用：创建子进程
    --无参
    --返回值：
        fork()的值返回两次,一次父进程,一次子进程。
        父进程返回子进程的ID
        子进程返回0,类似链表
        通过fork()的值区分父子进程
        返回-1表示失败,并设置error
*/

#include<sys/types.h>
#include<unistd.h>
#include<stdio.h>
int main()
{
    pid_t pid=fork();
    if(pid>0)
    {
        printf("%d\n",pid);
        printf("I am parent,my id is %d,my parent is %d\n",getpid(),getppid());
    }
    else if (pid==0)
    {
        printf("I am child,my id is %d,my parent is %d\n",getpid(),getppid());
    }

    // if(pid==0)
    // {
    //     printf("%d\n",pid);
    //     printf("I am parent,my id is %d,my parent is %d\n",getpid(),getppid());
    // }
    // else if (pid>0)
    // {
    //     printf("I am child,my id is %d,my parent is %d\n",getpid(),getppid());
    // }

    //父进程先执行还是子进程先执行？
    //parent为什么是1？
    
    // for(int i=0;i<5;i++)
    // {
    //     printf("%d\n",i);
    //     sleep(1);//让进程执行多一些时间
    // } 
}

/*
在没有添加for循环的时候，子进程getppid()得到的返回值为1。
原因是此时父进程被杀死(死亡)，子进程被init进程领养，可以在for循环中将子进程的存活时间设置得比父进程长，分别在父进程被杀死前后查看ppid，可以观察到这一变化。
*/
```

* 子进程并不是从文件头开始执行，而是fork()开始，并返回值0
* 子进程会复制父进程的代码
* 终端是个可执行文件(程序)，本身也是一个进程，也有ID

### fork()父子进程的虚拟地址空间

<img src="E:\Note\图片\fork虚拟地址空间.PNG" style="zoom:67%;" />

* 父子进程用户区一样
* 内核区pid不一样

### 写时拷贝

Linux 的 fork() 使用是通过写时拷贝实现。写时拷贝是一种**可以推迟甚至避免拷贝数据的技术**。内核并不复制整个进程的地址空间，而是让**父子进程共享同一个地址空间**。只有在**写入时才会复制地址空间**（重新开辟一块内存），从而使各个进程拥有自己的地址空间。即资源的复制只有在写入时才会进行，在此之前，只有以只读的方式进行。fork() 之后的父子进程共享文件，此时的 fork() 产生的子进程与父进程相同的文件描述符指向相同的文件表，引用计数增加，共享文件偏移指针。

## 进程状态

### 进程退出

* 子进程退出，父进程能获取的子进程的退出信息

<img src="E:\Note\图片\进程退出.PNG" style="zoom: 50%;" />

* _exit()

  Linux系统库

* exit()

  标准C库

  底层调用_exit()

  功能更强大(能刷新缓冲区)

  

### 孤儿进程

* 定义：父进程运行完成，子进程还未运行完成
* 出现孤儿进程，内核就把init(PID=1)设为其父进程，回收子进程资源
* 无危害

### 僵尸进程

* 子进程结束，用户区资源被释放，内核区PCB无法释放，需要由父进程释放
* 子进程终止，父进程尚未回收,子进程PCB残留在内核区中，形成僵尸进程
* 僵尸进程无法被kill -9杀死，(可能大量占用进程号)

## wait函数

```c
//函数原型
#include <sys/types.h>
#include <wait.h>
int wait(int *status)
```

* 调用wait进入阻塞状态，判断父进程的子进程是否已经运行完成

* 一个wait()只能回收一个子进程
* 调用成功，返回被收集的子进程的进程ID，如果调用进程没有子进程，调用就会失败，此时wait返回-1
