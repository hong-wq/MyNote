[TOC]

# MySQL    

英文术语 

* **CRUD**

  增、删、改、查

* **ACID**

  数据库事务的四大特性(原子，一致，持久)

* **DML**

  增、删、改

* **DDL**

  表结构修改

**极客45讲学习笔记**

[学习网址](https://time.geekbang.org/column/intro/100020801?tab=catalog)

## 基础篇

### 1.Mysql的基础架构

**一条sql语句的查询过程?**

* 基础架构

<img src="E:\Note\图片\Mysql\基础架构.PNG" style="zoom:80%;" />

* MySQL可分为**Server层**与**存储引擎层**两部分

  * 客户端
    * 发起执行请求

  * Server层

    * 提供mysql的**核心功能**
    * 包含所有**内置函数**的实现
    * 可以实现所有**跨存储引擎功能**，如存储过程、触发器、视图

  
  * 存储引擎层
  
    * 数据的**存储**与**提取**(读写接口)
  
    * 插件式、支持InnoDB(最常用)、Memory等**多种存储引擎**
  
      [^InnoDB]: MySQL 5.5.5 版本开始成为了默认存储引擎
  
* **Server层的四大组成**

  1. **连接器**

     * 与客户端建立连接

       1. TCP握手

       2. 身份验证(用户名与密码)

          [^验证错误]: Access denied for user

     * 获取权限

       通过验证、从**权限表**里查出**拥有的权限**

     * 维持与管理连接

       1. 连接后无后续动作，即空闲连接
       2. 空闲状态超过默认time_out(默认8h)，会断开
       3. 连接过程复杂，应**尽量使用长连接**

     * 长连接的问题

       会导致内存占用大

       解决方案

       1. **定期**断开长连接

       2. MySQL5.7以上版本、通过执行 mysql_reset_connection**初始化连接资源**

          

  2. **查询缓存**

     * 从缓存中查询是否执行过该条语句

     * 弊大于利

       查询缓存的失效非常频繁，只要有对一个表的更新，这个表上所有的查询缓存都会被清空，因此查询缓存的**命中率会非常低**，适用于静态表。

     * MySQL8.0已经删除该功能。

  3. **分析器**

     * 词法分析

       **解析字符串**、识别出字符串代表的含义

     * 语法分析

       对词法分析返回的结果，根据语法规则，判断是否满足语句**是否满足MySQL语法**。

       [^错误提示]: You have an error in your SQL syntax

  4. **优化器**

     ​	即优化执行效率

     * 在表里面有多个索引的时候，决定使用哪个索引(**索引选择**)

     * 在一个语句有多表关联（join）的时候，决定各个**表的连接顺序**。

  5. **执行器**

     * 操作引擎
     * 返回结果

### 2. 日志系统

**SQL更新语句的执行过程？**

* **两大日志模块**

  1. **redo log(重做日志)**

     **？？？**：redo是什么结构的？

     两种更新方式

     * 直接读写磁盘

       弊端：

       * **IO成本高**

         一更新就要写磁盘

       * **查找成本高**

         查找对应更新数据成本大(耗时)

       优化：

     * WAL技术：**！！！先写日志、再写磁盘**

       * 过程

         1. 需要更新时，InnoDB将记录写入redo log，不直接写入磁盘，并更新内存

            **？？？**：更新内存什么意思

         2. InnoDB在合适(一般是系统空闲时)时候将记录写入磁盘

       * redo log 满了怎么做？

         <img src="E:\Note\图片\Mysql\WAL.PNG" style="zoom: 67%;" />

         write pos：记录位置

         check posint：擦除记录的位置，即要写入磁盘的的数据

         **方式**：擦除一些记录，写入磁盘

       * **crash-safe**

         数据库异常重启时，之间提交的数据不会丢失

         

  2. **binlog(归档日志)**

     * Server层独有的日志

  3. **两者的不同**

     1. redo log为**InnoDB独有**，属于**引擎层**；

        binlog属于**Server层**，所有引擎都可以使用，跨引擎
  
     2. redo log为**物理**日志，记录的是数据页(物理页、磁盘)上的变化；
  
        binlog为**逻辑**日志，记录的是执行的逻辑上的变化，即像我们理解的mysql语句，但又不完全是，有两种模式 ：     statement:sql语句      row模式
  
     3. redo log循环写，固定空间会用完，会覆盖；
  
        binlog会追加写，写满会切换到下一个，不会覆盖
  
  4. **两阶段提交**
  
     //
  
     保证两份日志逻辑上的一致性
  
     * redo_log prepare
     * binlog write
     * redo_log commit
  
  5. **使用场景**
  
     binlog是基于备份和binlog中的sql语句恢复数据库，eg：从某个备份点(完整数据)+该备份点后的binlog 即可恢复；
  
     redo log(先写日志，后写磁盘)是为了保证事物提交后遇到crash，防止那些未写入磁盘、还保存在内存中的数据丢失，丢失后能马上恢复数据
  
  6. **为什么两者都要有**
  
     一个原因是，redolog只有InnoDB有，别的引擎没有。 另一个原因是，redolog是循环写的，不持久保存，binlog的“归档”这个功能，redolog是不具备的。  
  
  <img src="E:\Note\图片\Mysql\tow_log.PNG" style="zoom: 67%;" />

### 3. 索引

* 含义

  数据库管理系统中的**排序**的**数据结构**，mysql是$B^{+}$树，在磁盘中(会耗空间的...)

* 作用

  能缩小查询范围，提高查询效率，类似目录

* 结构

  * 主键索引和非主键索引结构都是$B^{+}$树

  * InnoDB磁盘管理的最小单位就是“页”，也就是说无论是叶子节点、非叶子节点和行数据，都是存放在页当中。 页组成结构有头部数据、主体数据和尾部数据。

  * 一个页存储多个叶子节点，叶子节点之间通过**双向链表串**接。因此，查找具体的叶节点时，还有一个遍历有序链表的过程，不过因为链表长度有限（受限于页大小，mysql默认16kb），这个时间可以接受

* 分类

  * 主键索引(聚簇索引)

    * 存储结构：B+树

      非叶子节点：主键值

      叶子节点：整行数据

    * 查询方式：eg，select * from T where ID=500

      只需搜索主键索引(ID树)这颗树

  * 非主键索引(二级索引)

    * 存储结构：B+树

      非叶子节点：非主键字段值

      叶子节点：主键的值

    * 查询方式：select * from T where k=5

      先搜索k索引树，得到ID值，在去搜索主键索引树，这个过程为**回表**

      （没有主键的表，innodb会给默认创建一个Rowid做主键）

    应该尽量使用主键索引

  * 索引的维护

    * 页合并
      * 相邻的两个页删除后，再合并
    * 页分裂
      * 插入数据时数据页满了，由B+树算法会新建一个数据页，然后挪动数据
      * 会降低性能，**空间利用率**

    * 自增主键的使用

      自增主键往往是更合理的选择,更好维护索引

      * 性能

        1. 插入是**追加**的方式，即获取最大ID值 + 1， 不会产生数据的挪动，不会产生页分裂
        2. 当采用逻辑字段作为主键，不易保证有序插入

      * 存储空间

        主键长度越小，普通索引的叶子节点就越小，普通索引占用的空间也就越小

  * 覆盖索引

    查询的字段在二级索引中已经存在，则无需进行回表

    ```mysql
    index(k)
    select id from T where k = xxxx
    ```

  * 联合索引

    多个字段组合成的索引 eg(a,b,c)

  * [最左匹配原则](https://blog.csdn.net/sinat_41917109/article/details/88944290?spm=1001.2101.3001.6650.1&utm_medium=distribute.pc_relevant.none-task-blog-2%7Edefault%7ECTRLIST%7Edefault-1-88944290-blog-112726517.pc_relevant_default&depth_1-utm_source=distribute.pc_relevant.none-task-blog-2%7Edefault%7ECTRLIST%7Edefault-1-88944290-blog-112726517.pc_relevant_default&utm_relevant_index=2)

    * eg.a,ab,abc(like a%),即前缀匹配

  * [索引下堆](https://baijiahao.baidu.com/s?id=1716515482593299829&wfr=spider&for=pc)

    可以在索引遍历过程中，对索引中包含的字段先做判断，直接过滤掉不满足条件的记录，**减少回表次数**

### 4.事务的隔离级别

https://blog.csdn.net/weixin_42404727/article/details/123751456

* 含义

  * 事务，是一组完整的业务逻辑，保证数据逻辑一致的最小操作单位
  * 本质就是多条DML的操作
  * 事务在引擎层实现

* 事务的四大特性：ACID

  1. 原子性：要么全部成功，要么全部失败，即最小操作单位。
  2. 隔离性：事务之间互不干扰
  3. 一致性：
  4. 持久性：事务提交，对数据库的修改时永久性的

* 并发问题

  脏读

  幻读

  不可重复读

* 四大隔离级别

  1. 读未提交

     一个事务读取到了另一个事务还未提交的数据

  2. 读已提交

     一个事务只能读取另一个事务已经提交后的数据

  3. 可重复读

     在一个事务的生命周期中(从启动事务begin - 提交事务commit)期间，所能读取到数据与刚启动事务时是一致的，其他事务的提交也不会有影响

  4. 串行化

     事务排队执行，不存在并发，读时与写时都会加锁。读写排斥，写写也排斥。当两个排斥先后执行时，后执行的事件要等前一个事件执行完毕才能继续执行

     * 关于锁
       * 读锁
         * 事务要读要加读锁，加了读锁只能读
         * 读锁即共享锁，多个读事件都可加锁
         * 加了读锁其他事务无法加写锁
         * 避免不可重复读(其他事务无法写)
       * 写锁
         * 事务要写要加写锁，加了写锁只能写
         * 写锁即排他锁，写锁与其他锁都互斥
         * 可避免脏读(只有一个事务写)

* read_view

* MVCC

  select * 从哪select?

  https://blog.csdn.net/qq_41784433/article/details/121183733
  
  避免长事务，主从延迟

### 5.锁机制

锁粒度越大，开销越小，锁冲突的概率越小，安全性也就越高，但业务并发度以及性能越差；反之锁粒度越小，开销也就越大，锁冲突的概率越大（易导致死锁），安全性也就越低，但业务并发度以及性能越好。

三类锁： 全局 -> 表级 - > 行

1. 全局锁

   * 含义

     即对整个数据库加锁，数据库进入只读状态，线程无法进行增删改与表结构修改(DML& DDL)

     MYSQL命令：Flush tables with read lock (FTWRL)

   * 应用

     全库的逻辑备份

     不加锁，会导致视图逻辑不一致

     <img src="E:\Note\图片\Mysql\全局锁.PNG" style="zoom:67%;" />

     

     1. 为了得到一致性的读视图，可以采用可重复读的隔离级别
     2. mysqldump备份工具使用 **-single-transaction**参数，就会开启一个事务

     

   * set global readonly=true模式与全局锁的异同

     * 同

       数据库都进入只读模式

     * 异

       在异常处理上，

       * 全局锁会自动释放，可以保证正常更新状态
       * readonly状态会一致保存，导致数据库无法正常更新，风险大

       

2. 表级锁

   * 表锁

     * 语法

       手动加：lock tables … read/write

     * 读锁与写锁

       读读不互斥，读写，写写均互斥

   * 元数据锁(MDL)

     防止DDL(表结构修改)与DML(增删改)并发发生冲突

     * 特点

       * 访问一个表时会自动加上，MYSQL5.5版本引入
       * 所有对表的增删改查操作都需要先申请 MDL 读锁
       * 事务中的 MDL 锁，在语句执行开始时申请，但是语句结束后并不会马上释放，而会等到整个事务提交后再释放。
       * server层的锁

     * 当对一个表进行增删改查时，加MDL读锁

       不能修改表结构，但能进行增删改查

     * 当对一个表进行表结构修改时，加MDL写锁

       能正常读写元数据，即修改表结构，但其他线程无法执行任何操作，包括表结构的修改与数据的增删改查

     * 关于读锁与写锁的阻塞问题

       https://blog.csdn.net/q2878948/article/details/96430129

     **在做表结构变更的时候，一定要小心不要导致锁住线上查询和更新。**

     

3. 行锁

   * 两段锁协议

     * 第一阶段

       扩展阶段、事务可以加任何类型的锁，但是不能释放锁

     * 第二阶段

       收缩阶段、事务只能释放锁，不能加锁

     * 与一次性加锁

       一次性加锁会直接把所有数据都加上锁

       两阶段不要求为所有数据都加上锁、因此会产生死锁，可串行化(因为分阶段了)

   * 特性

     * 由引擎层实现，InnoDB支持行锁，MYISAM不支持
     * 是需要时加上,事务commit才释放
     * 如果事务中需要锁多个行，要把最可能造成锁冲突、最可能影响并发度的锁尽量往后放

   * 死锁

     * 含义

       并发系统中出现**循环依赖**，涉及的线程都在**等待其他线程释放资源**，导致线程都进入无线等待的状况

     <img src="E:\Note\图片\Mysql\死锁.PNG" style="zoom:67%;" />

     * 处理死锁策略

       * 设置超时时间后自动退出

         * 太长，eg 50s（InnoDB 中，innodb_lock_wait_timeout 的默认值是 50s）

           等待成本太高，线程都在等待

         * 太短，eg 1s

           会造成误伤，例如只是锁的普通等待

       * 发起死锁检测

         * 发现死锁后，主动回滚死锁链条中的某一个事务，让其他事务得以继续执行。

         * 将参数 innodb_deadlock_detect 设置为 on，表示开启这个逻辑。

         * 机制

           每当一个事务被锁的时候，就要看看它所依赖的线程有没有被别人锁住，如此循环，最后判断是否出现了循环等待，也就是死锁，形成了一个环

           1. 事务A检测自己有没有被锁，如果有检测锁住他的事务B
           2. 如果B没被锁，即没有死锁，否则检测锁住他的C...
           3. 循环检测，最后没有线程被锁，即没有死锁；又检测到被A锁住，即代表有死锁
           4. 复杂度为$$o(n^2)$$，每一个线程都要检测其他线程锁住，1 + 2 + 3 +…… + n
           5. 可能没有死锁，但又白白检测，耗费大量CPU资源

         * 如何应对？
         
           1. 拆行、一行拆多行
         
              拆多行，最后汇总
         
           2. Server层限流（控制并发度）
         
              * 不能在客户端层控制，因为客户端多，即使每个客户端的并发数少，最后服务端也是高并发的场景
              * 可以使用中间件proxy？
              * 修改mysql源码？
         
           3. 关闭死锁检测
         
              应用于肯定不会出现死锁的业务
         
           4. 死锁检测其实就是算法，环的检测，不必每次遍历一遍当前事务，只需要判断事务链表中，每加入一个新事物后是否有环的生成，有就形成死锁。
         
           
